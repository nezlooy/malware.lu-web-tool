# -*- coding: utf-8 -*-

import re, operator, datetime, sys, os, glob
from core.Req import Req
from threading import Thread, enumerate as thread_enumerate
if sys.version_info[0] == 3:
	from urllib.parse import unquote, quote
	import json
else:
	from urllib import unquote, quote
	import simplejson as json

def sizeformat(num):
	for x in ['bytes', 'KB', 'MB', 'GB']:
		if num < 1024.0:
			return "%3.1f %s" % (num, x)
		num /= 1024.0
	return "%3.1f %s" % (num, 'TB')

class SampleDownloader(Thread):
	def __init__(self, tasks):
		super(SampleDownloader, self).__init__()
		self.tasks = tasks
		self.daemon = True
		self.start()
		self._name = self.name

	def process(self, cur, total):
		self.name = 'D %s %d' % (self.md5, int(float(cur) / total * 100))

	def done(self):
		self.md5 = None
		self.name = self._name
		self.tasks.task_done()

	def run(self):
		while True:
			md5 = self.tasks.get()
			if md5:
				self.md5 = md5
				resp, error = Req().request(self.app.config['malware.lu']['apiurl'] + '/download', {
					'hash': self.md5,
					'apikey': self.app.config['malware.lu']['apikey']
				})
				if not error:
					resp.save(self.app.downloads, progressfn = self.process, postfix = '.part')
				self.done()

class MluSample:
	def __init__(self, hashes = '', parseJSON = True):
		self.hashes = ','.join(hashes) if isinstance(hashes, list) else hashes
		self.parseJSON = parseJSON
		self.itemsperpage = self.app.config['itemsperpage']

	def __readJSON(self, url, data = {}):
		resp, error = Req().request(url, data)
		if not error:
			data = resp.read()
			return (json.loads(data) if self.parseJSON else data, resp.response.code)
		return (error, 503)

	def __dateFormat(self, date):
		date = datetime.datetime.strptime(date[0], '%d %b %Y') if date[0] else datetime.date.today() + datetime.timedelta(days = 0 - int(date[1]))
		return int(date.strftime('%s'))

	def info(self, allinfo = False):
		if self.hashes:
			data = {
				'resource': self.hashes,
				'apikey': self.app.config['virustotal.com']['apikey']
			}
			if allinfo:
				data['allinfo'] = 1
			return self.__readJSON(self.app.config['virustotal.com']['apiurl'], data)
		return ('', 400)

	def stats(self):
		return self.__readJSON(self.app.config['malware.lu']['apiurl'] + '/stats', {
			'apikey': self.app.config['malware.lu']['apikey']
		})

	def inDB(self):
		if self.hashes and isinstance(self.hashes, str):
			return self.__readJSON(self.config['malware.lu']['apiurl'] + '/check', {
				'hash': self.hashes,
				'apikey': self.app.config['malware.lu']['apikey']
			})
		return ('', 400)

	def download(self):
		exists = len(glob.glob(os.path.join(self.app.downloads, self.hashes + '.*'))) or self.hashes in [t for t in self.app.tasks.queue]
		if not exists:
			self.app.tasks.put(self.hashes)
		return { 'exists': exists }

	def downloads(self, page = 0):
		samples = [thread.name.split(' ')[1:] for thread in thread_enumerate() if thread.name.startswith('D')]
		samples += [[t, 0] for t in self.app.tasks.queue]
		samples += [[f.replace('.zip', ''), 100] for f in os.listdir(self.app.downloads) if f.endswith('.zip')]
		itemsperpage = self.app.config['itemsperpage']
		return {
			'samples': samples[itemsperpage * page : itemsperpage * (page + 1)],
			'count': len(samples),
			'maxpages': len(samples) // itemsperpage
		}

	def readDB(self, page = 0):
		ret = []
		if page > self.app.dbmaxpages or page < 0:
			page = 0
		self.app.dbfile.seek(self.app.dblinelength * self.itemsperpage * page)
		for i in range(self.itemsperpage):
			line = self.app.dbfile.readline()
			if not line:
				break
			ret.append(self.app.dbfile.readline().strip().split('|'))
		return ret

	def searchInDB(self, hashes = None):
		ret = {}
		self.app.dbfile.seek(0)
		hashes = hashes if hashes else self.hashes if self.hashes else []
		if isinstance(hashes, str):
			hashes = re.split(r',\s*', hashes)
		if hashes:
			hashes = map(lambda h: len(h) < 40 and h + '|' or len(h) > 40 and '|' + h or '|' + h + '|', hashes)
			for line in self.app.dbfile:
				for sample in hashes:
					if sample in line:
						line = line.strip().split('|')
						if not ret.has_key(line[0]):
							ret[line[0]] = line
			self.app.dbfile.seek(0)
		return ret.values()

	def searchOnVT(self, text):
		ret = {}
		resp, error = Req().request(self.app.config['googlesearch'] % quote('site:virustotal.com "%s"' % text))
		if not error:
			for item in re.findall(r'<li class="g">.*?</li>', resp.read()):
				url, date = item.split('</h3>')
				date = re.search(r'(\d{1,2}\s+\w{3}\s+\d{2,4})|(\d)\s+days?\s+ago', date, re.I)
				url = re.search(r'resource=([a-f0-9]{32,})|file/([a-f0-9]{32,})|scan/([a-f0-9]{32,})|analisis/([a-f0-9]{32,})', unquote(url), re.I)
				if url and date:
					url = filter(lambda u: u != None, url.groups())[0].lower()
					if not ret.has_key(url):
						ret[url] = self.__dateFormat(date.groups())
			items = [i[0] for i in sorted(ret.iteritems(), key = operator.itemgetter(1))[::-1]][:self.app.config['googlemaxresults']]
			return (self.searchInDB(items), resp.response.code)
		else:
			return ('Unable to connect to www.google.com. ' + error, 503)