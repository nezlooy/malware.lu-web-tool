# -*- coding: utf-8 -*-

import re, socket, os, sys
from shutil import copyfileobj
from tempfile import NamedTemporaryFile
from ssl import SSLError
if sys.version_info[0] == 3:
	from urllib.parse import unquote, quote, urlencode
	from urllib.error import HTTPError, URLError
	import urllib as urllib2
	from urllib.request import Request, build_opener
	from urllib.request import HTTPHandler, HTTPSHandler, HTTPDefaultErrorHandler, HTTPErrorProcessor, HTTPRedirectHandler, ProxyHandler
else:
	from urllib import unquote, quote, urlencode
	from urllib2 import HTTPError, URLError, build_opener, Request
	from urllib2 import HTTPHandler, HTTPSHandler, HTTPDefaultErrorHandler, HTTPErrorProcessor, HTTPRedirectHandler, ProxyHandler

class HeadRequest(Request):
	def get_method(self):
		return 'HEAD'

class Req:
	# proxy format: { 'http' : 'http://username:password@12.34.56.78:8080' }
	def __init__(self, proxy = {}):
		self.opener = build_opener(
			HTTPHandler(),
			HTTPSHandler(),
			HTTPDefaultErrorHandler(),
			HTTPErrorProcessor(),
			HTTPRedirectHandler()
		)
		self.headers = {
			'User-Agent': 'Yandex/1.01.001 (compatible; Win16; I)',
			'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
			'Accept-Language': 'en-us,en;q=0.5',
			'Accept-Charset': 'UTF-8,*;q=0.5',
			'Accept-Encoding': ''
		}
		if proxy:
			self.opener.add_handler(urllib2.ProxyHandler(proxy))

	def __setitem__(self, key, value):
		self.headers[key] = value

	def request(self, url, data = None, timeout = False, head = False):
		self.opener.addheaders = self.headers.items()
		if data:
			data = urlencode(dict([(k, v.encode('utf-8') if 'encode' in dir(v) else v) for k, v in data.iteritems()]))
		self.response = None
		error = False
		try:
			self.response = self.opener.open(HeadRequest(url) if head else url, data, timeout or self.timeout)
		except (HTTPError, URLError, socket.error, SSLError, socket.timeout, KeyboardInterrupt, ValueError), e:
			error = str(e.reason if 'reason' in dir(e) else e)
		return (self, error)

	def header(self, name, default = ''):
		return self.response.headers.getheader(name, default).strip() if self.response else None

	def fmode(self, write = 'w+'):
		ctype = self.header('Content-Type')
		return write if ctype and ctype.find('text/') == 0 else write + 'b'

	def read(self, bytes = -1):
		return self.response.read(bytes)

	def close(self):
		if self.response:
			self.response.close()

	def filename(self):
		cd = self.header('Content-Disposition')
		return re.findall(r'filename=(\S+)', cd)[0].replace('"', '') if cd else False

	# TODO: to remake this, because is a very difficult

	def saveRange(self, filepath, end = True, chunk_size = 8192, progressfn = None): # if !end, then will be write in the top
		total, cur = int(self.header('Content-length', '0')) if progressfn else 0, 0
		try:
			_filepath = filepath + '_'
			exists = os.path.exists(filepath)
			size = os.path.getsize(filepath) if exists else 0
			if not end and exists:
				if os.path.exists(_filepath):
					os.unlink(_filepath)
				os.rename(filepath, _filepath)
			f = open(filepath, self.fmode())
			if end:
				f.seek(size)
				if size:
					f.write('\n')
			if progressfn and total:
				while True:
					chunk = self.read(chunk_size)
					cur += len(chunk)
					if not chunk:
						break
					f.write(chunk)
					progressfn(cur, total)
			else:
				copyfileobj(self.response, f)
			if not end and exists:
				if size:
					f.write('\n')
				f2 = open(_filepath, self.fmode('r'))
				copyfileobj(f2, f)
				f2.close()
				os.unlink(_filepath)
			f.close()
			self.close()
		except IOError:
			return False
		return True

	# TODO: to remake this, because is a very difficult
	
	def save(self, filepath = None, chunk_size = 8192, progressfn = None, postfix = None):
		total, cur = int(self.header('Content-length', '0')) if progressfn else 0, 0
		if filepath and os.path.isdir(filepath):
			filename = self.filename()
			if filename:
				filepath = os.path.join(filepath, filename)
			else:
				self.close()
				return False
		try:
			f = open(filepath + (postfix or ''), self.fmode()) if filepath else NamedTemporaryFile(self.fmode(), delete = False)
			if progressfn and total:
				while True:
					chunk = self.read(chunk_size)
					cur += len(chunk)
					if not chunk:
						break
					f.write(chunk)
					progressfn(cur, total)
			else:
				copyfileobj(self.response, f)
			f.close()
			self.close()
			if filepath and postfix:
				os.rename(filepath + postfix, filepath)
		except IOError:
			return False
		return f.name