#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# TODO (global): normal check "Max download par day" in thread, when task was finished
# TODO (global): convert from files to the database, or provide a choice
# TODO (global): add upload-functionality
# TODO (global): to use backbone.js + zepto.js for the web-interface instead of bicycle
#

import os, sys, time
from argparse import ArgumentParser
from core.WebHandler import WebHandler, ThreadedHTTPServer
from core.MluSample import MluSample, SampleDownloader, sizeformat
from core.Req import Req
if sys.version_info[0] == 3:
	import json
	from queue import Queue
else:
	import simplejson as json
	from Queue import Queue

__description__ = 'Malware.lu Web tool'
__version__ = '0.1'
__license__ = 'GPLv2'
__author__ = '@nezlooy'

class App:
	def __init__(self):
		os.chdir(os.path.dirname(os.path.abspath(sys.argv[0])))
		self.config = json.loads(open('config.json').read())
		self.downloads = os.path.abspath(self.config['downloads'])
		self.debug = False

		self.dburl = self.config['malware.lu']['samplesurl']
		self.dbfilepath = os.path.join(self.downloads, os.path.basename(self.dburl))
		self.dbfilesize = os.path.getsize(self.dbfilepath) if os.path.exists(self.dbfilepath) else 0

		if not self.config['virustotal.com']['apikey'] or not self.config['malware.lu']['apikey']:
			print 'You need to have API-key for www.virustotal.com and www.malware.lu'
			return None

		Req.timeout = self.config['timeout']

		parser = ArgumentParser(description = __description__)
		parser.add_argument('--version', action = 'version', version = '%(prog)s version ' + __version__)
		parser.add_argument('-u', '--update', action = 'store_true', dest = 'update', default = False, help = 'Update www.malware.lu database of samples and exit')
		return self.updatedb() if parser.parse_args().update else self.web()

	def __updateprogress(self, current, total):
		percent = float(current) / total * 100
		format = '%c%sDownloaded %s of %s bytes (%0.2f%%)\r'
		sys.stdout.write(format % (chr(27), '[2K', sizeformat(current), sizeformat(total), percent))
		sys.stdout.flush()
		if current >= total:
			sys.stdout.write('\n')

	def updatedb(self):
		print 'Trying to update database of samples'
		r = Req()
		head, error = r.request(self.dburl, head = True)
		if not error:
			size = int(head.header('Content-length', '0'))
			if size == self.dbfilesize:
				print 'Already updated'
			else:
				if self.dbfilesize:
					size = size - self.dbfilesize - 2
					r['Range'] = 'bytes=%d-%d' % (0, size)
				resp, error = r.request(self.dburl)
				if not error:
					print 'Complete' if resp.saveRange(self.dbfilepath, end = False, progressfn = self.__updateprogress) else 'Fail'
				else:
					raise Exception(error)
		else:
			raise Exception('Unable to connect to www.malware.lu. Error: ' + error)

	def web(self):
		if self.dbfilesize:
			self.dbfile = open(self.dbfilepath, 'r')
			self.dblinelength = len(self.dbfile.readline())
			self.dbcount = int(self.dbfilesize / self.dblinelength)
			self.dbmaxpages = self.dbfilesize / self.dblinelength // self.config['itemsperpage']
			self.dbfile.seek(0)
		else:
			return self.updatedb()

		self.tasks = Queue()
		for _ in range(self.config['downloadthreads']):
			SampleDownloader(self.tasks)

		WebHandler.app = MluSample.app = SampleDownloader.app = self
		WebHandler.routes = {
			'GET': [
				[r'^/config$', 'config'],
				[r'^/stats$', 'stats'],
				[r'^/md5infos/(.*?)$', 'getinfos'],
				[r'^/download/([a-f0-9]{32})$', 'download'],
				[r'^/samples(/page(\d+))?$', 'samples'],
				[r'^/downloads(/page(\d+))?$', 'downloads']
			],
			'POST': [
				[r'^/search$', 'search']
			]
		}

		host = self.config['host']
		port = self.config['port']

		print 'Database malware.lu contains %d samples' % self.dbcount
		print 'Server\'s listening on %s:%d' % (host, port)

		httpd = ThreadedHTTPServer((host, port), WebHandler)
		try:
			httpd.serve_forever()
		except KeyboardInterrupt:
			httpd.socket.close()

if __name__ == '__main__':
	app = App()